#!/usr/bin/env node
/**
 * Session Memory Hook (Stop)
 * Auto-saves structured session summaries to daily memory files.
 * Consumes stats accumulated by loop-detector hook.
 *
 * Saves to: ~/.claude/projects/<project>/memory/sessions/YYYY-MM-DD-<id>.md
 * Auto-cleanup: files older than 30 days are removed.
 */

const fs = require("fs");
const path = require("path");

const MAX_AGE_DAYS = 30;
const TEMP = process.env.TEMP || "/tmp";
const STATS_FILE = path.join(TEMP, "claude-session-stats.json");

function readStdin() {
  try {
    return fs.readFileSync(0, "utf8");
  } catch {
    return "{}";
  }
}

function getDateStr() {
  return new Date().toISOString().slice(0, 10);
}

function getTimeStr() {
  return new Date().toISOString().slice(11, 16);
}

function loadStats() {
  try {
    return JSON.parse(fs.readFileSync(STATS_FILE, "utf8"));
  } catch {
    return null;
  }
}

function clearStats() {
  try {
    fs.unlinkSync(STATS_FILE);
  } catch {
    // best-effort
  }
}

function cleanOldFiles(dir) {
  try {
    const files = fs.readdirSync(dir);
    const cutoff = Date.now() - MAX_AGE_DAYS * 86400000;
    for (const file of files) {
      if (!/^\d{4}-\d{2}-\d{2}-.+\.md$/.test(file)) continue;
      const filePath = path.join(dir, file);
      const stat = fs.statSync(filePath);
      if (stat.mtimeMs < cutoff) {
        fs.unlinkSync(filePath);
      }
    }
  } catch {
    // best-effort
  }
}

function formatDuration(ms) {
  const mins = Math.round(ms / 60000);
  if (mins < 60) return `${mins}min`;
  const h = Math.floor(mins / 60);
  const m = mins % 60;
  return `${h}h${m > 0 ? m + "min" : ""}`;
}

function topTools(toolCounts, limit) {
  return Object.entries(toolCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, limit)
    .map(([name, count]) => `${name}(${count})`)
    .join(", ");
}

function shortenPath(p) {
  // Shorten Windows paths for readability
  return p
    .replace(/^C:\\Users\\arnau\\/i, "~/")
    .replace(/\\/g, "/");
}

try {
  const input = JSON.parse(readStdin());
  const stopReason = input.stop_reason || "";
  const sessionId = process.env.CLAUDE_SESSION_ID || "unknown";

  // Load accumulated stats from loop-detector
  const stats = loadStats();

  // Only save if meaningful work was done
  const totalCalls = stats ? stats.totalCalls : 0;
  if (totalCalls < 3) {
    clearStats();
    process.exit(0);
  }

  // Determine memory directory — use sessions/ subdirectory
  const projectDir = process.env.CLAUDE_PROJECT_DIR || "";
  const home = process.env.HOME || process.env.USERPROFILE || "";
  let memoryDir;

  if (projectDir) {
    const escapedProject = projectDir.replace(/[\\/:]/g, "-").replace(/^-+|-+$/g, "");
    memoryDir = path.join(home, ".claude", "projects", escapedProject, "memory", "sessions");
  } else {
    memoryDir = path.join(home, ".claude", "memory", "sessions");
  }

  fs.mkdirSync(memoryDir, { recursive: true });

  const dateStr = getDateStr();
  const timeStr = getTimeStr();
  const shortId = sessionId.slice(0, 8);
  const fileName = `${dateStr}-${shortId}.md`;
  const filePath = path.join(memoryDir, fileName);

  // If file exists, append a counter
  let finalPath = filePath;
  if (fs.existsSync(filePath)) {
    let counter = 2;
    while (fs.existsSync(path.join(memoryDir, `${dateStr}-${shortId}-${counter}.md`))) {
      counter++;
    }
    finalPath = path.join(memoryDir, `${dateStr}-${shortId}-${counter}.md`);
  }

  // Calculate duration
  const duration = stats && stats.startedAt ? formatDuration(Date.now() - stats.startedAt) : "?";

  // Build structured summary
  const lines = [
    `# Session: ${dateStr} ${timeStr}`,
    `**ID**: ${shortId} | **Duration**: ${duration} | **Calls**: ${totalCalls} | **Errors**: ${stats ? stats.errors : 0}`,
    "",
  ];

  // Tool usage breakdown
  if (stats && stats.toolCounts) {
    lines.push(`## Tools`);
    lines.push(topTools(stats.toolCounts, 10));
    lines.push("");
  }

  // Files modified
  if (stats && stats.filesModified && stats.filesModified.length > 0) {
    lines.push(`## Files Modified`);
    for (const f of stats.filesModified) {
      lines.push(`- ${shortenPath(f)}`);
    }
    lines.push("");
  }

  // Files read (top 10 only)
  if (stats && stats.filesRead && stats.filesRead.length > 0) {
    lines.push(`## Files Read`);
    const shown = stats.filesRead.slice(0, 10);
    for (const f of shown) {
      lines.push(`- ${shortenPath(f)}`);
    }
    if (stats.filesRead.length > 10) {
      lines.push(`- ...and ${stats.filesRead.length - 10} more`);
    }
    lines.push("");
  }

  // Context
  lines.push(`## Context`);
  lines.push(`- **Project**: ${projectDir ? shortenPath(projectDir) : "global"}`);
  lines.push(`- **Stop**: ${stopReason || "user"}`);
  lines.push("");

  lines.push("---");
  lines.push("*Auto-generated by session-memory hook*");
  lines.push("");

  fs.writeFileSync(finalPath, lines.join("\n"));

  // Clean old files and clear stats
  cleanOldFiles(memoryDir);
  clearStats();
} catch {
  // Hook must never block — fail silently
  process.exit(0);
}
