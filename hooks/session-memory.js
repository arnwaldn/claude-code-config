#!/usr/bin/env node
/**
 * Session Memory Hook (Stop)
 * Auto-saves a lightweight session summary to daily memory files.
 * Inspired by openclaw's session-memory pattern.
 *
 * Saves to: ~/.claude/projects/<project>/memory/YYYY-MM-DD-<slug>.md
 * Auto-cleanup: files older than 30 days are removed.
 */

const fs = require("fs");
const path = require("path");

const MAX_AGE_DAYS = 30;

function readStdin() {
  try {
    return fs.readFileSync(0, "utf8");
  } catch {
    return "{}";
  }
}

function slugify(text) {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "")
    .slice(0, 40);
}

function getDateStr() {
  const d = new Date();
  return d.toISOString().slice(0, 10);
}

function cleanOldFiles(memoryDir) {
  try {
    const files = fs.readdirSync(memoryDir);
    const cutoff = Date.now() - MAX_AGE_DAYS * 86400000;
    for (const file of files) {
      // Only clean auto-generated daily files (YYYY-MM-DD-*.md), not MEMORY.md
      if (!/^\d{4}-\d{2}-\d{2}-.+\.md$/.test(file)) continue;
      const filePath = path.join(memoryDir, file);
      const stat = fs.statSync(filePath);
      if (stat.mtimeMs < cutoff) {
        fs.unlinkSync(filePath);
      }
    }
  } catch {
    // Cleanup is best-effort
  }
}

try {
  const input = JSON.parse(readStdin());
  const stopReason = input.stop_reason || "";
  const sessionId = process.env.CLAUDE_SESSION_ID || "unknown";

  // Determine memory directory
  // Try project-specific memory first, fall back to global
  const projectDir = process.env.CLAUDE_PROJECT_DIR || "";
  let memoryDir;

  if (projectDir) {
    // Project-specific: ~/.claude/projects/<escaped-path>/memory/
    const escapedProject = projectDir.replace(/[\\/:]/g, "-").replace(/^-+|-+$/g, "");
    memoryDir = path.join(
      process.env.HOME || process.env.USERPROFILE || "",
      ".claude",
      "projects",
      escapedProject,
      "memory"
    );
  } else {
    memoryDir = path.join(
      process.env.HOME || process.env.USERPROFILE || "",
      ".claude",
      "memory"
    );
  }

  // Ensure directory exists
  fs.mkdirSync(memoryDir, { recursive: true });

  // Build summary from loop-detector state (tool call count proxy)
  const loopStateFile = path.join(
    process.env.TEMP || "/tmp",
    "claude-loop-detector.json"
  );
  let toolCallCount = 0;
  try {
    const loopState = JSON.parse(fs.readFileSync(loopStateFile, "utf8"));
    toolCallCount = (loopState.history || []).length;
  } catch {
    // No loop state = short session
  }

  // Only save if meaningful work was done (proxy: >3 tool calls tracked)
  if (toolCallCount < 3) {
    process.exit(0);
  }

  const dateStr = getDateStr();
  const slug = slugify(stopReason || sessionId);
  const fileName = `${dateStr}-${slug}.md`;
  const filePath = path.join(memoryDir, fileName);

  // Don't overwrite if already exists (multiple sessions same day)
  if (fs.existsSync(filePath)) {
    process.exit(0);
  }

  const content = [
    `# Session ${dateStr}`,
    "",
    `- **Session ID**: ${sessionId.slice(0, 8)}...`,
    `- **Stop reason**: ${stopReason || "unknown"}`,
    `- **Tool calls tracked**: ${toolCallCount}`,
    `- **Project**: ${projectDir || "global"}`,
    "",
    "---",
    "*Auto-generated by session-memory hook. Edit MEMORY.md for curated notes.*",
    "",
  ].join("\n");

  fs.writeFileSync(filePath, content);

  // Clean old files
  cleanOldFiles(memoryDir);
} catch {
  // Hook must never block â€” fail silently
  process.exit(0);
}
